"""
base_transformer.py

GENERATED BY METAPROJECT 1.10.0.
"""
from __future__ import annotations
from typing import Any, Annotated
from typing import TYPE_CHECKING
from loguru_wrapper import loguru

# vendor
from pydantic import BaseModel, BeforeValidator, Field

# generated
# from llm.generated.__core import logger_wrapper



if TYPE_CHECKING:
    from loguru_wrapper import LoguruWrapper

# Reusable conversion types
def to_string(v) -> str:
    """Convert value to string."""
    return str(v)

def to_int(v) -> int:
    """Convert value to int."""
    return int(v)

StringCoerced = Annotated[str, BeforeValidator(to_string)]
IntCoerced = Annotated[int, BeforeValidator(to_int)]

class GeneratedInitializationParams(BaseModel):
    """Pydantic model that holds arguments to initialize
    BaseTransformer class.
    """
    transformers_model_name: str = "t5-base"
    cache_dir: str = "/tmp/transformers_cache"
    model_type: str = "PreTrainedModel"
    tokenizer_type: str = "PreTrainedTokenizerBase"


class BaseTransformer:
    """
    BaseTransformer class is a generated class for llm project.
    It contains attributes and methods that are automatically generated based on
    the project configuration.

    _transformers_model_name: str
    _cache_dir: str
    _model_type: str
    _tokenizer_type: str
    """

    def __init__(self, *args, **kwargs):
        """
        Initialize the BaseTransformer class with given arguments.
        """
        self.__application_name = "llm"
        self._extension = kwargs.pop('extension', None)

        

        # Initial values
        self._initialization_params = GeneratedInitializationParams(**kwargs)

        # Current values
        self._transformers_model_name = self.initialization_params().transformers_model_name
        self._cache_dir = self.initialization_params().cache_dir
        self._model_type = self.initialization_params().model_type
        self._tokenizer_type = self.initialization_params().tokenizer_type


    @property
    def extension(self):
        """
        Get the extension of the BaseTransformer.
        This is used to access the extension of this class.
        """
        return self._extension

    # --------------------------------------------------------------------------
    # Generated attributes
    # --------------------------------------------------------------------------
    @property
    def transformers_model_name(self) -> str:
        """
        Get the value of the transformers_model_name attribute.
        """
        return self._transformers_model_name


    @transformers_model_name.setter
    def transformers_model_name(self, value: str):
        
        if not isinstance(value, str):
            raise TypeError(f"Expected str, got {type(value).__name__}")
        
        self._transformers_model_name = value

    @transformers_model_name.deleter
    def transformers_model_name(self):
        """
        Delete the transformers_model_name attribute.
        """
        del self._transformers_model_name

    @property
    def cache_dir(self) -> str:
        """
        Get the value of the cache_dir attribute.
        """
        return self._cache_dir


    @cache_dir.setter
    def cache_dir(self, value: str):
        
        if not isinstance(value, str):
            raise TypeError(f"Expected str, got {type(value).__name__}")
        
        self._cache_dir = value

    @cache_dir.deleter
    def cache_dir(self):
        """
        Delete the cache_dir attribute.
        """
        del self._cache_dir

    @property
    def model_type(self) -> str:
        """
        Get the value of the model_type attribute.
        """
        return self._model_type


    @model_type.setter
    def model_type(self, value: str):
        
        if not isinstance(value, str):
            raise TypeError(f"Expected str, got {type(value).__name__}")
        
        self._model_type = value

    @model_type.deleter
    def model_type(self):
        """
        Delete the model_type attribute.
        """
        del self._model_type

    @property
    def tokenizer_type(self) -> str:
        """
        Get the value of the tokenizer_type attribute.
        """
        return self._tokenizer_type


    @tokenizer_type.setter
    def tokenizer_type(self, value: str):
        
        if not isinstance(value, str):
            raise TypeError(f"Expected str, got {type(value).__name__}")
        
        self._tokenizer_type = value

    @tokenizer_type.deleter
    def tokenizer_type(self):
        """
        Delete the tokenizer_type attribute.
        """
        del self._tokenizer_type


    # --------------------------------------------------------------------------
    # Instance methods
    # --------------------------------------------------------------------------
    def initialization_params(self) -> GeneratedInitializationParams:
        """
        Get initialization parameters for the generated class.
        """
        return self._initialization_params


    def logger(self) -> LoguruWrapper:
        """
        Get logger for the generated class.

        offset 4: caller
        offset 3: extension.BaseGenerator.logger
        offset 2: generated.<ClassName>.logger
        """
        return loguru(offset=4)

    def application_name(self):
        """Application name"""
        return self.__application_name


    def package_name(self):
        """Package name is an alias for application name"""
        return self.application_name()


    def keys(self) -> list:
        """
        Get keys from initialization params.
        """
        return list(
            filter(
                lambda x: not x.startswith('_'),
                self.initialization_params().__dict__.keys()
            )
        )

    def get(self, key, default=None) -> Any:
        """
        Get attribute value.
        """
        return getattr(self, key, default)


    def __getattr__(self, name: str, default=None) -> Any:
        """
        Get attribute value.
        """
        return self.to_dict().get(name) or default


    def to_dict(self) -> dict:
        """
        Convert generated class to dictionary.
        """
        return self.initialization_params().model_dump(exclude_none=True)


    def as_dict(self) -> dict:
        """
        Alias for to_dict() method.
        """
        return self.to_dict()


    def attrs_to_string(self) -> list:
        """
        Convert attributes to string representation.
        """
        return [f"{key}={value}" for key, value in self.to_dict().items()]


    def __str__(self) -> str:
        """String representation of the generated class."""
        return f"{', '.join(self.attrs_to_string())}"


    def __repr__(self) -> str:
        """Representation of the generated class."""
        return f"BaseTransformer({', '.join(self.attrs_to_string())})"


    def inspect_object(self):
        """
        Inspect the generated class and return its attributes, properties, and methods.
        """
        instance_attrs = list(self.__dict__.keys())
        class_attrs = [
            k for k, v in self.__class__.__dict__.items()
            if not callable(v) and not isinstance(v, property)
        ]
        properties = [
            k for k, v in self.__class__.__dict__.items()
            if isinstance(v, property)
        ]
        methods = [
            k for k, v in self.__class__.__dict__.items()
            if callable(v)
        ]
        return {
            "instance_attributes": instance_attrs,
            "class_attributes": class_attrs,
            "properties": properties,
            "methods": methods,
        }


    def get_attr_raise(self, key):
        """
        Raise AttributeError instead KeyError.
        """
        try:
            return self.__dict__[key]
        except KeyError as e:
            raise AttributeError(f"Attribute {key} not found") from e


    # --------------------------------------------------------------------------
    # Class methods
    # --------------------------------------------------------------------------
    @classmethod
    def cls_logger(cls) -> LoguruWrapper:
        """
        Get class logger for the generated class.
        """
        return loguru()


    @classmethod
    def from_dict(cls, *args, **kwargs) -> BaseTransformer:
        """
        Create an instance of the class from a dictionary.

        Args:
            params: Dictionary containing initialization parameters.
        """
        return cls(*args, **kwargs)
